https://www.nowcoder.com/ta/sql

1. 查找最晚入职员工的所有信息

select * from employees order by hire_date DESC limit 1

2. 查找入职时间倒数第三晚的员工的所有信息

select * from employees order by hire_date DESC limit 1 offset 2

3. 查找当前薪水详情以及对应的部门编号dept_no

select s.*, d.dept_no 
from salaries as s, dept_manager as d
where s.emp_no = d.emp_no
and d.to_date = '9999-01-01' 
and s.to_date = '9999-01-01'
order by s.emp_no

4. 查找所有已经分配部门的员工的first name和last name

select e.last_name, e.first_name, d.dept_no 
from employees e inner join dept_emp d             # inner join(等值连接) 只返回两个表中联结字段相等的行
on e.emp_no = d.emp_no


5. 查找所有员工的last name和first name以及对应的部门编号dept_no

select e.last_name, e.first_name, d.dept_no
from employees as e left join dept_emp as d
on e.emp_no = d.emp_no

6. 查找所有员工入职时候的薪水情况

select s.emp_no, s.salary
from salaries s, employees e
where s.from_date = e.hire_date and s.emp_no = e.emp_no
order by emp_no DESC

7. 查找薪水变动超过15次的员工号emp_no以及其变动次数t

select s.emp_no, count(s.emp_no) as t
from salaries s 
group by s.emp_no having t > 15

# 1、用COUNT()函数和GROUP BY语句可以统计同一emp_no值的记录条数
# 2、根据题意，输出的涨幅次数为t，故用AS语句将COUNT(emp_no)的值转换为t
# 3、由于COUNT()函数不可用于WHERE语句中，故使用HAVING语句来限定t>15的条件
# 4、最后存在一个理解误区，涨幅超过15次，salaries中相应的记录数应该超过16（从第2条记录开始算作第1次涨幅），不过题目为了简单起见，将第1条记录当作第1次涨幅，所以令t>15即可


8. 找出所有员工当前具体的salary情况

select distinct s.salary from salaries s
where s.to_date = '9999-01-01'
order by salary DESC


9. 获取所有部门当前manager的当前薪水情况

select d.dept_no, d.emp_no, s.salary
from dept_manager d left join salaries s
on d.emp_no = s.emp_no
where d.to_date = '9999-01-01' and s.to_date = '9999-01-01'
order by dept_no 


10. 获取所有非manager的员工的emp_no

select emp_no from employees
where emp_no not in (select emp_no from dept_manager)


11. 获取所有员工当前的manager

select d1.emp_no, d2.emp_no 
from dept_emp d1 left join dept_manager d2
on d1.dept_no = d2.dept_no
where d2.to_date = '9999-01-01' and d1.emp_no <> d2.emp_no


12. 获取每个部门中当前员工薪水最高的相关信息

# 50%通过率
select d.dept_no, d.emp_no, max(s.salary)
from dept_emp d inner join salaries s
on d.emp_no = s.emp_no
where d.to_date = '9999-01-01' and s.to_date = '9999-01-01'
group by d.dept_no
order by d.dept_no DESC 


13. 从titles表获取按照title进行分组

select title, count(title) as t
from titles 
group by title


14. 从titles表获取按照title进行分组，注意对于重复的emp_no进行忽略

# 题目隐含：在某一段时间内，有员工的emp_no和title相同
select title, count(distinct emp_no) as t
from titles
group by title
having t >= 2


15. 查找employees表

select emp_no, birth_date, first_name, last_name, gender, hire_date
from employees 
where emp_no % 2 = 1 and last_name != 'Mary'
order by hire_date DESC


16. 统计出当前各个title类型对应的员工当前薪水的对应的平均工资

select t.title, avg(s.salary)
from titles t inner join salaries s
on t.emp_no = s.emp_no
where t.to_date = '9999-01-01' and s.to_date = '9999-01-01'
group by t.title


17. 获取当前薪水第二多的员工的emp_no以及其对应的薪水salary

select emp_no, salary
from salaries
where to_date = '9999-01-01'
order by salary DESC limit 1 offset 1

18. 查找当前薪水第二多的员工的相关信息，不使用order by




19. 查找所有员工的last_name和first_name以及对应的dept_name

select last_name, first_name, dept_name
from (employees e left join dept_emp dp on e.emp_no = dp.emp_no)
left join departments ds on dp.dept_no = ds.dept_no

# outer join will include null values.


20. 查找员工编号emp_now为10001其自入职以来的薪水salary涨幅值growth

select (max(salary) - min(salary)) as growth
from salaries
where emp_no = 10001


21. 查找所有员工自入职以来的薪水涨幅情况

select e.emp_no, (max(s.salary) - min(s.salary)) as growth
from (e.emp_no, s.salary 
      from employees e left join salaries s on e.emp_no =s.emp_no)
where s.to_date != '9999-01-01'
order by growth 

# 未通过


22. 统计各个部门的工资记录数

select ds.dept_no, ds.dept_name, count(salary) as sum
from (dept_emp de inner join departments ds on de.dept_no = ds.dept_no) 
    inner join salaries s on de.emp_no = s.emp_no
group by dept_no
order by dept_no 


23. 对所有员工的当前薪水按照salary进行按照1-N的排名




24. 获取所有非manager员工当前的薪水情况




25. 获取员工




26. 




29. 使用join查询方式找出没有分类的电影id以及名称

select f.film_id as 电影id, f.title as 名称
from film as f left join film_category fc on f.film_id = fc.film_id
where category_id is null


30. 使用子查询的方式找出属于Action分类的所有电影对应的title, description

# 非子查询方式
select f.title, f.description
from (film f inner join film_category fc on f.film_id = fc.film_id)
    inner join category c on fc.category_id = c.category_id 
where c.name = 'Action'

# 子查询方式
select f.title, f.description
from film f
where f.film_id in 
      (select fc.film_id from film_category fc where fc.category_id 
            in (select c.category_id from category c where c.name = 'Action'))
















